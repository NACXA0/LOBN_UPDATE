- 使用示例：
    1. 【基础】导入库
        ```
        #导入库
        from sqlmodel import Field, Session, SQLModel, create_engine, select
        ```
     2. 【基础】连接数据库
        ```
        # 连接数据库
        CONFIG = json.loads(open('config.json', 'r', encoding='utf-8').read())['DataBase'] 
        db_url = str("postgresql+psycopg2://" + str(CONFIG['user']) + ":" + str(CONFIG['password']) + "@" + str(
        CONFIG["host"]) + ":" + str(
        CONFIG['port']) + "/" + str(CONFIG['dbname']))
        engine = create_engine(db_url, echo=True)  # 其中一个悲观测试的参数（连接前先ping一下）：pool_pre_ping=True
        ```
     3. 【基础】为一个表创建实例（指定一个表的内容）（导入一个表的内容）
        ``` 
        # 为一个表创建实例（指定一个表的内容）（导入一个表的内容）
        class 表的函数名(SQLModel, table=True):   # 必须： 这个类名需要和表名一致，否则使用__tablename__ = "表名"。table=True需要加上
            #【重要！！必须！！】指定架构名
            __table_args__ = {"schema": "main_schema"}
            #【重要！不必要】指定表名，如果类名不是表名。需要用这种形式指定出来。
            __table_name__ = "user"  #如果类名不是表名。需要用这种形式指定出来。

            #下面是列
            id: int | None = Field(default=None, primary_key=True)
            uuid: str
            name: str
        ```
     4. 【功能函数】
         - 搜索：
         ```
             def select_heroes():
                 with Session(engine) as session:
                 statement = select(表的函数名)#.where(表的函数名.某列的名)#where选取其中某列
                 #print("statement=",statement)
                 results = session.exec(statement)
                 for user in results:
                     print(user)
         ```
        - 创建：
        ```
            def create_heroes():
                #1定义要提交的内容：
                table_name_1 = table_name(uuid="2d96d66c-7d3e-4838-9888-a73ec503a05b", id=3)
                table_name_2 = table_name(uuid="72aa21fe-2818-4220-a0e1-e40f58c6f3b7", id=4)
                table_name_3 = table_name(uuid="8f9442ff-f733-4e59-a56e-e04c9fef9683", id=5, name="CCC")
                #2执行：
                with Session(engine) as session:
                    session.add(table_name_1)
                    session.add(table_name_2)
                    session.add(table_name_3)
                #3提交：
                session.commit()
        
        ```
        - 合并:
        ```
            类似于add，区别是在遇到唯一约束键时更新其他数据
            session.merge()
        
        ```
        - 修改：
        ```
        with Session(engine) as session:
            statement = select(Hero).where(Hero.name == "Spider-Boy")
            results = session.exec(statement)
            hero = results.one()

            hero.age = 16
        
            session.add(hero)  #这里可以不加，ORM有自动检查   （这还有一个错误检测功能，不加这个有时候失败不报错）（修改量很大的情况还是加上，可能有性能影响）
        ```
        
        ``` 
        场景：多态关联：一个中间表，两个数据表，中间表有id和表名。
        JOIN(被查询者（子表）)
        【特殊】外键定义在“一”那一侧：连接表有一个字段指定了id具体是那一张数据表的id，让数据表指向连接表，而不是连接表指向数据表（这样连接表的外键得关联很多数据表）。
        模型定义：
            var: str = Field(default_factory=None, foreign_key="架构名.表名.字段名")
        检索示例：
            command = select(表1.字段1, 表2.字段2).join(表2).where(表1.字段1 == '值')   select顺序无所谓

        ```
        


- 命名解释：
  1. 直接命名：
    - name
      - 姓名
  2. 行为-事务/动词-名词命名：
    - create_date
      - 创建时间
    - last_login_date    对动词加以背景说明：last_login
      - 最后登陆时间
  3. 属性 & 名词命名：      名词与属性的先后取决于主体/优先阐述业务主体，如org_base业务关键在于身份，video_list业务关键在于视频
     1. 属性-名词命名
        - org_base
          - 基地组织/作为基地这个身份具有的数据
     2. 名词-属性命名：
          - video_list
            - 视频列表
  4. 关联表：   map 2 代表关联表与表的中间表/任何一段不是一个表，都不可使用map
     - 产品标识_map_user2identity_
       - 关联表  关联user与identity_的
  5. 页面设置表：    WebPageSet代表页面设置   index代表相关的页面   main_carousel是页面中的位置   img_path_list是事务属性/名词   
    - WebPageSet_index_main_carousel_img_path_list
      - 页面设置-首页-主要的-轮播图-路径-列表
      - 就是最显眼位置的哪个轮播图的路径列表


- 数据库结构：
  - 



- postgresql 数据类型映射到 sqlmodel 的模板写法 收集
  - 类型：text[]   写法：var: List[str] = Field(sa_column=Column(ARRAY(Text)))    # from sqlmodel import ARRAY, Text
  - 类型：jsonb[]  写法：var: list = Field(sa_type=JSON, default=[])    # 注意要加[],  虽然单个{}也是兼容的，但这里用[{}，{}]
  - 类型jsonb      写法：var: dict = Field(sa_type=JSON)
  - 类型：uuid     写法：var: str    自动创建的写法：uuid: str = Field(default_factory=uuid7)  
  - 类型：datetime 写法：var: str    自动创建写法：var: str = Field(default_factory=lambda: datetime.datetime.now(datetime.UTC).strftime("%Y-%m-%d %H:%M:%S"))


- 性能优化说明：
  - 善用select：
    - 不要select(table), 这样是找出所有的列
    - 只找出需要的列：select(table.item1, table.item2)
    - 只找出需要的列，意味着只可对这些列进行操作，其他列无法操作。
    - 

- 学习：
  - 操作JSON内的某数组：
    1. 将此数组传为dict   关键！
    2. 改变此dict
    3. 将此dict赋予json
  - sqlmodel不能检测过深数据的更改，例如：不能检测json数据中，值为列表的数据的更改：
    - 解决方案：
      ```
         from sqlalchemy.orm.attributes import flag_modified
         with (Session(engine) as session):
            找出的数据 = session.exec(select(table)).first()
            flag_modified(找出的数据, '字段名')  # 将实例标记为 'dirty' 
            session.commit()
      ```
    - 原始问题：
      - sqlmodel
        问题：为什么更改不能被保存？
        如何修改才能保存？
      - 
        现有数据库表table：
        id  data
        '1'   {"test": ['1','2','3']}
      - 模型：
      class table(SQLModel, table=True):
          id: str = Field(primary_key=True)
          data: dict = Field(sa_type=JSONB)
      - 修改
      with (Session(engine) as session):
          command = select(table).where(table.id == '1')
          info_data = session.exec(command).first()
          print('原始数据', info_data.data['test'])
          info_data.data['test'].append('4')
          print('期望添加的数据', info_data.data['test'])
          session.commit()  # 4. 提交
      - 检测修改
        with Session(engine) as session:
            command = select(table).where(table.id == '1')
            info_data = session.exec(command).first()
            print('检测更改后的数据', info_data.data['test'])
  - 